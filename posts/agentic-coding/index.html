<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Agentic Coding: 当编程被按下加速键 | Tai's Blog</title><meta name=keywords content="agentic-coding,prompt,claude-code"><meta name=description content="Cursor 刚火起来的时候自己还是比较保守的，或者说不想费事去搞，毕竟在从业者眼中 Agentic Coding 还多半是一个「半成品」的状态，因为一个半成品而消耗自己的精力，这"><meta name=author content><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="eAKh7zszsOtNde1wyq_sUo95ZPH4zTTJhR-_ol4VWDs"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://yunpengtai.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://yunpengtai.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://yunpengtai.top/favicon-32x32.png><link rel=apple-touch-icon href=http://yunpengtai.top/apple-touch-icon.png><link rel=mask-icon href=http://yunpengtai.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>MathJax={loader:{load:["[tex]/boldsymbol"]},tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,tags:"all",packages:{"[+]":["boldsymbol"]}},chtml:{scale:.9}}</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml-full.js integrity="sha256-kbAFUDxdHwlYv01zraGjvjNZayxKtdoiJ38bDTFJtaQ=" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y3CX2RWEDY"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y3CX2RWEDY",{anonymize_ip:!1})}</script><meta property="og:title" content="Agentic Coding: 当编程被按下加速键"><meta property="og:description" content="Cursor 刚火起来的时候自己还是比较保守的，或者说不想费事去搞，毕竟在从业者眼中 Agentic Coding 还多半是一个「半成品」的状态，因为一个半成品而消耗自己的精力，这"><meta property="og:type" content="article"><meta property="og:url" content="http://yunpengtai.top/posts/agentic-coding/"><meta property="og:image" content="http://yunpengtai.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-12T16:07:00+08:00"><meta property="article:modified_time" content="2025-07-12T16:07:00+08:00"><meta property="og:site_name" content="Tai's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yunpengtai.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Agentic Coding: 当编程被按下加速键"><meta name=twitter:description content="Cursor 刚火起来的时候自己还是比较保守的，或者说不想费事去搞，毕竟在从业者眼中 Agentic Coding 还多半是一个「半成品」的状态，因为一个半成品而消耗自己的精力，这"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yunpengtai.top/posts/"},{"@type":"ListItem","position":3,"name":"Agentic Coding: 当编程被按下加速键","item":"http://yunpengtai.top/posts/agentic-coding/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Agentic Coding: 当编程被按下加速键","name":"Agentic Coding: 当编程被按下加速键","description":"Cursor 刚火起来的时候自己还是比较保守的，或者说不想费事去搞，毕竟在从业者眼中 Agentic Coding 还多半是一个「半成品」的状态，因为一个半成品而消耗自己的精力，这","keywords":["agentic-coding","prompt","claude-code"],"articleBody":"Cursor 刚火起来的时候自己还是比较保守的，或者说不想费事去搞，毕竟在从业者眼中 Agentic Coding 还多半是一个「半成品」的状态，因为一个半成品而消耗自己的精力，这显然是不值当的。后来，接触了 Cursor 之后，的确是了解了一些高效的用法，比如快速地写函数注释以及参数的 type，抑或是快速了解新 repo 的某些代码段作用。现在，使用了 Claude Code，可以确信地说，Claude Code + IDE (Vscode / Cursor) 才是真正高效的编程，编程不仅可以更快，同时可以更好，而在编程的过程自己也能学的更多\n以下将分为几个大的部分来详细介绍如何更好地使用 Claude Code (CC) 部分内容参考自 Anthropic Best Practices\n安装 首先是在 IDE 终端内完成对 CC 的安装，这里泛指 Vscode 类 IDE，用 IDE 的原因很简单，CC Desktop 的更改是终端式的，不便于查看；而 CC 在 IDE 中可以新建一个窗口，非常方便查看差别（除非该终端是计算节点）（注：如果是 Remote 开发，在 Remote 开发机中装即可）\n# 没有 npm 可以去官网进行安装: https://nodejs.org/en/download npm install -g @anthropic-ai/claude-code 接着安装插件：Claude Code，如果是 Remote 开发，记得装到 Remote 机器上\n运行时 CC 会对「区域」进行检测，有些区域会被 block，可以用这个跳过：\necho '{ \"hasCompletedOnboarding\": true }' \u003e ~/.claude.json 接着设置 API Base 和 Key 即可进行玩耍：\nexport ANTHROPIC_BASE_URL=xxx export ANTHROPIC_API_KEY=xxx 最后开启终端输入 claude 即可\n如果你说 Claude 又贵又容易被封，代理站不稳定，那么为什么不试试便宜又同样好用的 kimi/k2 呢？去官网的 API 开通之后，即可使用：\nexport ANTHROPIC_BASE_URL=https://api.moonshot.ai/anthropic export ANTHROPIC_API_KEY=月之暗面的 key 基本元素 CLAUDE.md 如果你需要让 CC 可以在修改 repo 的时候如鱼得水，那么你需要给其一份有关于 repo 的 manual，当然它可以每次都自己探索理解，但这样效率低而且不如你告诉它来的精准。这份 manual 在 CC 中即为「CLAUDE.md」，里面包含 repo 的信息以及「你需要它额外记住」的信息\n那么如何得到 CLAUDE.md 呢？当然你可以纯手写，那样效率不高。我们可以让 CC 自己生成，只需要在终端中输入 /init 命令即可，这是第一步。接着你还需要：\n修改不正确的：毕竟让它直接理解肯定会出现问题，比如 Development Commands（就是运行的命令） 开发示例：有些模块之间会有比较复杂依赖，可以给它一些修改的示例，即 Development Notes，比如你可以教它添加新优化器实现的步骤 工具使用：如果你自己手搓了一些「工具」，也可以单独放在 Tools 章节 除了以上这些，还可以使其原先的表述更加精准，或是加上一些它未曾注意到的，精准的开发需要精确的信息作为辅助 除了 repo 相关的信息可以放在 CLAUDE.md，我们还可以将写代码的注意点放进去，比如 Coding Style，还有 Getting Help 部分。以下是个人示例：\n## Best Practices ### Code Style - Make the code neat and pythonic - Follow existing patterns in the codebase. NEVER write new features into a file without first having a complete understanding of its underlying logic - Make the smallest reasonable changes to get to the desired outcome - DO NOT simply override the current code to implement new feature. Use configuration unless I told you to remove some feature - You MUST ask permission before reimplementing features or systems from scratch instead of updating the existing implementation - Use type hints, but omit the return type for functions that return `None` - Single quotes are preferred over double quotes - Use specific function or variable name ### Getting help - ALWAYS ask for clarification rather than making assumptions. - If you're having trouble with something, it's ok to stop and ask for help. Especially if it's something your human might be better at. 总而言之，CLAUDE.md 应该包括以下部分：\n运行代码的命令（训练，单元测试等） 代码的整体结构（训练，模型，数据，优化器等）以及不同 python 文件所负责的 module 代码的参数配置：参数的含义是什么，这个可以按照 module 来划分 如何修改不同的 module (Development Notes) Coding Style 以及一些额外的信息 另外还可以让 CC 假装不熟悉 repo，让其对 CLAUDE.md 进行补充以便让新手上手并修改 repo\nCommands 一些重复的 prompt 可以收集起来，变成特定的命令，方便直接调用，在项目根目录创建 .claude/commands，将命令以 *.md 的形式添加进该目录即可在 CC 中调用。比如创建 fix-issue.md：\nPlease analyze and fix the GitHub issue: `$ARGUMENTS.$` Follow these steps: 1. Use `gh issue view` to get the issue details 2. Understand the problem described in the issue 3. Search the codebase for relevant files 4. Implement the necessary changes to fix the issue 5. Write and run tests to verify the fix 6. Ensure code passes linting and type checking 7. Create a descriptive commit message 8. Push and create a PR Remember to use the GitHub CLI (`gh`) for all GitHub-related tasks. 使用 / 来唤出命令，即 /fix-issue: ... 即可使用该命令\n工作流 比较直接的就是让 CC 直接给你实现某个 feature，但这样通常不高效，因为这其实涉及了「阅读 -\u003e 思考 -\u003e 写代码」几个流程，一下子完成就容易出错。复杂的任务应该拆分为步骤来完成（除非实现的特别简单），而不同的工作流可以用 command 来表示，这样调用的时候比较方便\nRead-Plan-Code-Submit 四个英文单词分别代表一个「动作」，即将写代码拆分为四个过程：\nRead：你可以指定其阅读特定的内容，比如 model.py，或者 URL，图像等等，让其充分理解相关的内容，并强调该过程只需要理解不需要写代码 Plan: 阅读完之后，让其对需要实现的东西列一个简要的计划，以便你进行检查 Code: 这一步就是让它正式写代码 Submit：让其写完代码后进行 github submit，并且把你的需求和它的实现清单都放上去，方便日后 review 当然如果是方便测试的代码，可以在 Code 之后加上 Test，让其保证本地运行无报错或是通过单元测试才可进行 Submit\nTest-Code-Iterate-Submit 与上方不同，第一个动作变成了「Test」，即单元测试的意思，之所以放在第一位，是因为如果先写代码再写 test，很有可能 test 就比较专注于当前的实现，会忽略一些特殊的 cases（就好像自己检查自己的代码，比较难看出问题）\n其实这个工作流的核心就是「test-iterate」，让模型提前写好单元测试，并且不断其迭代，直到通过测试。这种工作流比较适合于需求非常精确，可用测试具体化的任务，比如后端 API 调用，或者是你让其重构当前代码，将「老代码的运行结果作为对照」\n如果有时候比较模糊，比如 UI 开发，也可以将 test 换成「screenshot」，让其对照截图来不断完善实现\n人为干预 人为干预是和任意工作流一起配合使用，毕竟 CC 是一步步实现需求，如果有时候实现错误，人为进行干预会得到更精确的结果，全自动说实话人也没办法放心。比较常用的是以下几种：\n按 Esc 直接打断 连续按两次 Esc，可以在历史中回跳选择，比如当前实现错误，而之前都是对的情况就可以用 复杂任务的 prompt 对于复杂 \u0026 精确的任务，我们需要好的 prompt 让其完成工作，当然简单的任务有时候也需要更加精确的 prompt，一般情况下怎么写好的 prompt 可以参见我之前的博客 How to Prompt LLMs Better? ，下面针对 CC 开发来说一下好的 prompt 还需要满足什么（老生常谈的 specific 就不聊了）\n强调顺序性 当任务复杂时，尤其是不同步骤看起来有点像的时候，很容易直接进行合并，而合并会带来更大的复杂度，多半结果差强人意。那么，此时就需要一些 prompt 来让其遵循顺序，不要跳步：\n**Objective: Example Command** **Directive:** Your task is to process the request defined by ``$ARGUMENTS`. You MUST follow the five-phase process outlined below in strict sequential order. **Combining phases or proceeding to the next phase before explicitly completing the current one is a critical failure.** For each phase, you will announce its start, perform the required tasks, produce the specified deliverable, and then announce its completion before moving on.$` --- ## Phase 1: This is Phase 1 **Objective:** This is the objective of Phase 1 **Tasks:** 1. xxx 2. xxx **Transition:** After xxx, state: \"Phase 1 Complete. Proceeding to Phase 2.\" --- ## Phase 2: This is Phase 2 **Objective:** This is the objective of Phase 2 **Tasks:** 1. xxx 2. xxx **Transition:** After xxx, state: \"**Phase 2 Complete. Proceeding to Phase 3.**\" 上方的 prompt 模板基本上在复杂任务上可以让模型一步一步来进行编程，而不会一下子突然合并，然后暴毙\n将指令编程化 如果你将 Agent 当成一种代码来写，大概率都能得到满意的结果，比如我在做 k2 demo 的时候，最后的 HTML Report 需要加上所有的图片，而有时候随着图片生成的数量一多起来，加上整个过程本来就是非常复杂的连续推理，模型很容易就忘掉。一开始尝试的就是「上强度」，比如加入 **Critical**: You must attach all the figures into HTML report 这种字眼，但其实模型还是做不到，或者骗自己全部加上\n此时正确的做法应该是，将该指令尽可能向编程靠齐，如果你要写代码判断是否全部添加，比较朴素的思维就是，先 list 出图片原来一共有多少，再 grep HTML 中 src 为图片的数量，两者进行对比，如果对不上，则说明有图片被遗漏。那么就可以将上述过程写入 prompt，你还可以将对应的 bash 命令告诉它，这样之后，它多半情况都能正确添加，哪怕图片数量多\n复杂的 prompt 是否合理 你会不会觉得 CLAUDE.md 已经够长了，加上模型还需要游走仓库各个文件，此时如果 prompt 写的复杂，会不会反倒起副作用？ 结论是不必担心，确保 prompt 和完成的任务复杂度成正比即可，你的任务如果无比简单，那没必要用复杂的 prompt；而如果你的任务是多步精确的推理，那么你的 prompt 复杂点反倒会让其执行地更加精确\n让 Gemini 出手 有些时候可以让 Gemini 来修改你的 prompt，这里之所以是 Gemini，是因为其是所有 LLMs 最话痨的一个，会事无巨细地修改你的 prompt，让其更加精确具体，比如：\nMy objective is to xxx. Please re-frame the following prompt to make it easier for LLMs agents to follow. \u003cYour Prompt\u003e 当然，别忘了对其返回的结果进行二次修改，多半情况下 Gemini 还会顺手把不需要改的地方也改了，也可以在一开始输入时限制它不要这么做。总之，检查还是必要的~\n使用场景 Repo QA 这个其实是最靠谱的功能（写代码会出错，这个大概率不会），当上手一个新仓库时，或者阅读一段比较费解的代码，有时候可以让 CC 进行解释，以下列出几种提问方式：\nHow is the logging module implemented? Why does the line 139 in xxx.py call function a()? What is the meaning of parameter p on line 139 of xxx.py? 这个还可以反着用，当你在一个项目上加越来越多 feature，潜在的依赖关系就会越来越复杂，有时候你可能忙着实现一个 feature 而忘记一些依赖关系，也可以先让 CC 进行分析，此时就可以提前规避错误\nLinter 这个是我经常使用的功能，写完代码后，可以让 CC 对代码进行检查，查看其是否符合 pythonic and neat 的要求，常见的修改需求如下：\n将某个大函数拆分为几个原子化的小函数 修改某个变量 / 函数的名字使其更加具体和精确 对复杂的模块及其参数添加注释 对函数的变量加上 type 标识 Git Related 除了 Repo QA，CC 还可以 Git QA，比如你好奇某个模块的功能是在哪个 commit 实现的，或者是想要问责是哪个实现导致了目前的报错\n同时还可以让 CC 帮助你完成 git 的提交，比如写 commit message 以及自动化 push\nTips /clear 可以直接清除所有上下文 Shift+Tab 可以灵活切换状态，比如「自动接受」 修改命令之后得重启 CC 才可以生效 可以向 CC 传数据，比如图片，或者是读取 URL 文件，本地文件可以通过路径来读，还可以使用管道命令，比如 cat foo.txt | claude 多个 Claude 协同，这个适合一个 Claude 解决不了的时候，可以开两个终端，每个 CC 负责不同的功能，比如一个实现，一个检查 使用一些额外的工具，比如 MCP（Model Context Protocol），当然你也可以写一些「工具代码」供其调用 重要的提示词：比如 IMPORTANT，YOU MUST 来强调服从性；思考相关的：think, think hard, think harder（适合 Claude 模型） 有时候我们想一直「自动运行」，但它有时候会弹出一些「命令申请」，此时就可以在 .claude/settings.local.json 内加入一些命令的权限管理： { \"env\": { \"BASH_DEFAULT_TIMEOUT_MS\": \"3000000\" // bash command 超时时间 }, \"permissions\": { \"allow\": [ \"Bash(*)\", // 允许终端执行所有命令 \"Bash(python:*)\" // 允许终端执行各种 Python 命令 ], \"deny\": [] } } ","wordCount":"4056","inLanguage":"en","datePublished":"2025-07-12T16:07:00+08:00","dateModified":"2025-07-12T16:07:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://yunpengtai.top/posts/agentic-coding/"},"publisher":{"@type":"Organization","name":"Tai's Blog","logo":{"@type":"ImageObject","url":"http://yunpengtai.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://yunpengtai.top accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://yunpengtai.top/archives/ title=归档><span>归档</span></a></li><li><a href=http://yunpengtai.top/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=http://yunpengtai.top/categories/%E6%8A%98%E8%85%BE title=折腾><span>折腾</span></a></li><li><a href=http://yunpengtai.top/tags/ title=标签><span>标签</span></a></li><li><a href=http://yunpengtai.top/friends/ title=友人><span>友人</span></a></li><li><a href=http://yunpengtai.top/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yunpengtai.top>Home</a>&nbsp;»&nbsp;<a href=http://yunpengtai.top/posts/>Posts</a></div><h1 class=post-title>Agentic Coding: 当编程被按下加速键</h1><div class=post-meta><span title='2025-07-12 16:07:00 +0800 CST'>July 12, 2025</span>&nbsp;·&nbsp;4056 words</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%ae%89%e8%a3%85 aria-label=安装>安装</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e5%85%83%e7%b4%a0 aria-label=基本元素>基本元素</a><ul><li><a href=#claudemd aria-label=CLAUDE.md>CLAUDE.md</a></li><li><a href=#commands aria-label=Commands>Commands</a></li></ul></li><li><a href=#%e5%b7%a5%e4%bd%9c%e6%b5%81 aria-label=工作流>工作流</a><ul><li><a href=#read-plan-code-submit aria-label=Read-Plan-Code-Submit>Read-Plan-Code-Submit</a></li><li><a href=#test-code-iterate-submit aria-label=Test-Code-Iterate-Submit>Test-Code-Iterate-Submit</a></li><li><a href=#%e4%ba%ba%e4%b8%ba%e5%b9%b2%e9%a2%84 aria-label=人为干预>人为干预</a></li></ul></li><li><a href=#%e5%a4%8d%e6%9d%82%e4%bb%bb%e5%8a%a1%e7%9a%84-prompt aria-label="复杂任务的 prompt">复杂任务的 prompt</a><ul><li><a href=#%e5%bc%ba%e8%b0%83%e9%a1%ba%e5%ba%8f%e6%80%a7 aria-label=强调顺序性>强调顺序性</a></li><li><a href=#%e5%b0%86%e6%8c%87%e4%bb%a4%e7%bc%96%e7%a8%8b%e5%8c%96 aria-label=将指令编程化>将指令编程化</a></li><li><a href=#%e5%a4%8d%e6%9d%82%e7%9a%84-prompt-%e6%98%af%e5%90%a6%e5%90%88%e7%90%86 aria-label="复杂的 prompt 是否合理">复杂的 prompt 是否合理</a></li><li><a href=#%e8%ae%a9-gemini-%e5%87%ba%e6%89%8b aria-label="让 Gemini 出手">让 Gemini 出手</a></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af aria-label=使用场景>使用场景</a><ul><li><a href=#repo-qa aria-label="Repo QA">Repo QA</a></li><li><a href=#linter aria-label=Linter>Linter</a></li><li><a href=#git-related aria-label="Git Related">Git Related</a></li></ul></li><li><a href=#tips aria-label=Tips>Tips</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>Cursor 刚火起来的时候自己还是比较保守的，或者说不想费事去搞，毕竟在从业者眼中 Agentic Coding 还多半是一个「半成品」的状态，因为一个半成品而消耗自己的精力，这显然是不值当的。后来，接触了 Cursor 之后，的确是了解了一些高效的用法，比如快速地写函数注释以及参数的 type，抑或是快速了解新 repo 的某些代码段作用。现在，使用了 Claude Code，可以确信地说，Claude Code + IDE (Vscode / Cursor) 才是真正高效的编程，编程不仅可以更快，同时可以更好，而在编程的过程自己也能学的更多</p><p>以下将分为几个大的部分来详细介绍如何更好地使用 Claude Code (CC)
<span class=sidenote-number><small class=sidenote>部分内容参考自 <a href=https://www.anthropic.com/engineering/claude-code-best-practices>Anthropic Best Practices</a></small></span></p><h2 id=安装>安装<a hidden class=anchor aria-hidden=true href=#安装>#</a></h2><p>首先是在 IDE 终端内完成对 CC 的安装，这里泛指 Vscode 类 IDE，用 IDE 的原因很简单，CC Desktop 的更改是终端式的，不便于查看；而 CC 在 IDE 中可以新建一个窗口，非常方便查看差别（除非该终端是计算节点）（注：如果是 Remote 开发，在 Remote 开发机中装即可）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 没有 npm 可以去官网进行安装: https://nodejs.org/en/download</span>
</span></span><span class=line><span class=cl>npm install -g @anthropic-ai/claude-code
</span></span></code></pre></div><p>接着安装插件：Claude Code，如果是 Remote 开发，记得装到 Remote 机器上</p><p>运行时 CC 会对「区域」进行检测，有些区域会被 block，可以用这个跳过：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>echo</span> <span class=s1>&#39;{ &#34;hasCompletedOnboarding&#34;: true }&#39;</span> &gt; ~/.claude.json
</span></span></code></pre></div><p>接着设置 API Base 和 Key 即可进行玩耍：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>export</span> <span class=nv>ANTHROPIC_BASE_URL</span><span class=o>=</span>xxx
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>ANTHROPIC_API_KEY</span><span class=o>=</span>xxx
</span></span></code></pre></div><p>最后开启终端输入 <code>claude</code> 即可</p><p>如果你说 Claude 又贵又容易被封，代理站不稳定，那么为什么不试试便宜又同样好用的 kimi/k2 呢？去官网的 API 开通之后，即可使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>export</span> <span class=nv>ANTHROPIC_BASE_URL</span><span class=o>=</span>https://api.moonshot.ai/anthropic
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>ANTHROPIC_API_KEY</span><span class=o>=</span>月之暗面的 key
</span></span></code></pre></div><h2 id=基本元素>基本元素<a hidden class=anchor aria-hidden=true href=#基本元素>#</a></h2><h3 id=claudemd>CLAUDE.md<a hidden class=anchor aria-hidden=true href=#claudemd>#</a></h3><p>如果你需要让 CC 可以在修改 repo 的时候如鱼得水，那么你需要给其一份有关于 repo 的 manual，当然它可以每次都自己探索理解，但这样效率低而且不如你告诉它来的精准。这份 manual 在 CC 中即为「CLAUDE.md」，里面包含 repo 的信息以及「你需要它额外记住」的信息</p><p>那么如何得到 CLAUDE.md 呢？当然你可以纯手写，那样效率不高。我们可以让 CC 自己生成，只需要在终端中输入 <code>/init</code> 命令即可，这是第一步。接着你还需要：</p><ul><li>修改不正确的：毕竟让它直接理解肯定会出现问题，比如 <code>Development Commands</code>（就是运行的命令）</li><li>开发示例：有些模块之间会有比较复杂依赖，可以给它一些修改的示例，即 <code>Development Notes</code>，比如你可以教它添加新优化器实现的步骤</li><li>工具使用：如果你自己手搓了一些「工具」，也可以单独放在 <code>Tools</code> 章节</li><li>除了以上这些，还可以使其原先的表述更加精准，或是加上一些它未曾注意到的，精准的开发需要精确的信息作为辅助</li></ul><p>除了 repo 相关的信息可以放在 CLAUDE.md，我们还可以将写代码的注意点放进去，比如 Coding Style，还有 Getting Help 部分。以下是个人示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-md data-lang=md><span class=line><span class=cl><span class=gu>## Best Practices
</span></span></span><span class=line><span class=cl><span class=gu></span>
</span></span><span class=line><span class=cl><span class=gu>### Code Style
</span></span></span><span class=line><span class=cl><span class=gu></span>
</span></span><span class=line><span class=cl><span class=k>-</span> Make the code neat and pythonic
</span></span><span class=line><span class=cl><span class=k>-</span> Follow existing patterns in the codebase. NEVER write new features into a file without first having a complete understanding of its underlying logic
</span></span><span class=line><span class=cl><span class=k>-</span> Make the smallest reasonable changes to get to the desired outcome
</span></span><span class=line><span class=cl><span class=k>-</span> DO NOT simply override the current code to implement new feature. Use configuration unless I told you to remove some feature
</span></span><span class=line><span class=cl><span class=k>-</span> You MUST ask permission before reimplementing features or systems from scratch instead of updating the existing implementation
</span></span><span class=line><span class=cl><span class=k>-</span> Use type hints, but omit the return type for functions that return <span class=sb>`None`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Single quotes are preferred over double quotes
</span></span><span class=line><span class=cl><span class=k>-</span> Use specific function or variable name
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>### Getting help
</span></span></span><span class=line><span class=cl><span class=gu></span>
</span></span><span class=line><span class=cl><span class=k>-</span> ALWAYS ask for clarification rather than making assumptions.
</span></span><span class=line><span class=cl><span class=k>-</span> If you&#39;re having trouble with something, it&#39;s ok to stop and ask for help. Especially if it&#39;s something your human might be better at.
</span></span></code></pre></div><p>总而言之，CLAUDE.md 应该包括以下部分：</p><ul><li>运行代码的命令（训练，单元测试等）</li><li>代码的整体结构（训练，模型，数据，优化器等）以及不同 python 文件所负责的 module</li><li>代码的参数配置：参数的含义是什么，这个可以按照 module 来划分</li><li>如何修改不同的 module (Development Notes)</li><li>Coding Style 以及一些额外的信息</li></ul><p>另外还可以让 CC 假装不熟悉 repo，让其对 CLAUDE.md 进行补充以便让新手上手并修改 repo</p><h3 id=commands>Commands<a hidden class=anchor aria-hidden=true href=#commands>#</a></h3><p>一些重复的 prompt 可以收集起来，变成特定的命令，方便直接调用，在项目根目录创建 <code>.claude/commands</code>，将命令以 <code>*.md</code> 的形式添加进该目录即可在 CC 中调用。比如创建 <code>fix-issue.md</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-md data-lang=md><span class=line><span class=cl>Please analyze and fix the GitHub issue: <span class=sb>`$ARGUMENTS.$`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Follow these steps:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>1.</span> Use <span class=sb>`gh issue view`</span> to get the issue details
</span></span><span class=line><span class=cl><span class=k>2.</span> Understand the problem described in the issue
</span></span><span class=line><span class=cl><span class=k>3.</span> Search the codebase for relevant files
</span></span><span class=line><span class=cl><span class=k>4.</span> Implement the necessary changes to fix the issue
</span></span><span class=line><span class=cl><span class=k>5.</span> Write and run tests to verify the fix
</span></span><span class=line><span class=cl><span class=k>6.</span> Ensure code passes linting and type checking
</span></span><span class=line><span class=cl><span class=k>7.</span> Create a descriptive commit message
</span></span><span class=line><span class=cl><span class=k>8.</span> Push and create a PR
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Remember to use the GitHub CLI (`gh`) for all GitHub-related tasks.
</span></span></code></pre></div><p>使用 <code>/</code> 来唤出命令，即 <code>/fix-issue: ...</code> 即可使用该命令</p><h2 id=工作流>工作流<a hidden class=anchor aria-hidden=true href=#工作流>#</a></h2><p>比较直接的就是让 CC 直接给你实现某个 feature，但这样通常不高效，因为这其实涉及了「阅读 -> 思考 -> 写代码」几个流程，一下子完成就容易出错。复杂的任务应该拆分为步骤来完成（除非实现的特别简单），而不同的工作流可以用 command 来表示，这样调用的时候比较方便</p><h3 id=read-plan-code-submit>Read-Plan-Code-Submit<a hidden class=anchor aria-hidden=true href=#read-plan-code-submit>#</a></h3><p>四个英文单词分别代表一个「动作」，即将写代码拆分为四个过程：</p><ol><li><em>Read</em>：你可以指定其阅读特定的内容，比如 <code>model.py</code>，或者 URL，图像等等，让其充分理解相关的内容，<em>并强调该过程只需要理解不需要写代码</em></li><li><em>Plan</em>: 阅读完之后，让其对需要实现的东西列一个简要的计划，以便你进行检查</li><li><em>Code</em>: 这一步就是让它正式写代码</li><li><em>Submit</em>：让其写完代码后进行 github submit，并且把你的需求和它的实现清单都放上去，方便日后 review</li></ol><p>当然如果是方便测试的代码，可以在 Code 之后加上 Test，让其保证本地运行无报错或是通过单元测试才可进行 Submit</p><h3 id=test-code-iterate-submit>Test-Code-Iterate-Submit<a hidden class=anchor aria-hidden=true href=#test-code-iterate-submit>#</a></h3><p>与上方不同，第一个动作变成了「Test」，即单元测试的意思，之所以放在第一位，是因为如果先写代码再写 test，很有可能 test 就比较专注于当前的实现，会忽略一些特殊的 cases（就好像自己检查自己的代码，比较难看出问题）</p><p>其实这个工作流的核心就是「test-iterate」，让模型提前写好单元测试，并且不断其迭代，直到通过测试。这种工作流比较适合于需求非常精确，可用测试具体化的任务，比如后端 API 调用，或者是你让其重构当前代码，将「老代码的运行结果作为对照」</p><p>如果有时候比较模糊，比如 UI 开发，也可以将 test 换成「screenshot」，让其对照截图来不断完善实现</p><h3 id=人为干预>人为干预<a hidden class=anchor aria-hidden=true href=#人为干预>#</a></h3><p>人为干预是和任意工作流一起配合使用，毕竟 CC 是一步步实现需求，如果有时候实现错误，人为进行干预会得到更精确的结果，全自动说实话人也没办法放心。比较常用的是以下几种：</p><ul><li>按 Esc 直接打断</li><li>连续按两次 Esc，可以在历史中回跳选择，比如当前实现错误，而之前都是对的情况就可以用</li></ul><h2 id=复杂任务的-prompt>复杂任务的 prompt<a hidden class=anchor aria-hidden=true href=#复杂任务的-prompt>#</a></h2><p>对于复杂 & 精确的任务，我们需要好的 prompt 让其完成工作，当然简单的任务有时候也需要更加精确的 prompt，一般情况下怎么写好的 prompt 可以参见我之前的博客
<span class=sidenote-number><small class=sidenote><a href=https://yunpengtai.top/posts/better-prompt/>How to Prompt LLMs Better?</a></small></span>
，下面针对 CC 开发来说一下好的 prompt 还需要满足什么（老生常谈的 specific 就不聊了）</p><h3 id=强调顺序性>强调顺序性<a hidden class=anchor aria-hidden=true href=#强调顺序性>#</a></h3><p>当任务复杂时，尤其是不同步骤看起来有点像的时候，很容易直接进行合并，而合并会带来更大的复杂度，多半结果差强人意。那么，此时就需要一些 prompt 来让其遵循顺序，不要跳步：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-md data-lang=md><span class=line><span class=cl>**Objective: Example Command**
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gs>**Directive:**</span> Your task is to process the request defined by ``$ARGUMENTS`. You MUST follow the five-phase process outlined below in strict sequential order. <span class=gs>**Combining phases or proceeding to the next phase before explicitly completing the current one is a critical failure.**</span> For each phase, you will announce its start, perform the required tasks, produce the specified deliverable, and then announce its completion before moving on.$`
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>---
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Phase 1: This is Phase 1
</span></span></span><span class=line><span class=cl><span class=gu></span>
</span></span><span class=line><span class=cl><span class=gs>**Objective:**</span> This is the objective of Phase 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gs>**Tasks:**</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>1.</span> xxx
</span></span><span class=line><span class=cl><span class=k>2.</span> xxx
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gs>**Transition:**</span> After xxx, state: &#34;Phase 1 Complete. Proceeding to Phase 2.&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>---
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Phase 2: This is Phase 2
</span></span></span><span class=line><span class=cl><span class=gu></span>
</span></span><span class=line><span class=cl><span class=gs>**Objective:**</span> This is the objective of Phase 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gs>**Tasks:**</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>1.</span> xxx
</span></span><span class=line><span class=cl><span class=k>2.</span> xxx
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gs>**Transition:**</span> After xxx, state: &#34;**Phase 2 Complete. Proceeding to Phase 3.**&#34;
</span></span></code></pre></div><p>上方的 prompt 模板基本上在复杂任务上可以让模型一步一步来进行编程，而不会一下子突然合并，然后暴毙</p><h3 id=将指令编程化>将指令编程化<a hidden class=anchor aria-hidden=true href=#将指令编程化>#</a></h3><p>如果你将 Agent 当成一种代码来写，大概率都能得到满意的结果，比如我在做 k2 demo 的时候，最后的 HTML Report 需要加上所有的图片，而有时候随着图片生成的数量一多起来，加上整个过程本来就是非常复杂的连续推理，模型很容易就忘掉。一开始尝试的就是「上强度」，比如加入 <code>**Critical**: You must attach all the figures into HTML report</code> 这种字眼，但其实模型还是做不到，或者骗自己全部加上</p><p>此时正确的做法应该是，将该指令尽可能向编程靠齐，如果你要写代码判断是否全部添加，比较朴素的思维就是，先 list 出图片原来一共有多少，再 grep HTML 中 src 为图片的数量，两者进行对比，如果对不上，则说明有图片被遗漏。那么就可以将上述过程写入 prompt，你还可以将对应的 bash 命令告诉它，这样之后，它多半情况都能正确添加，哪怕图片数量多</p><h3 id=复杂的-prompt-是否合理>复杂的 prompt 是否合理<a hidden class=anchor aria-hidden=true href=#复杂的-prompt-是否合理>#</a></h3><p>你会不会觉得 CLAUDE.md 已经够长了，加上模型还需要游走仓库各个文件，此时如果 prompt 写的复杂，会不会反倒起副作用？ 结论是不必担心，确保 prompt 和完成的任务复杂度成正比即可，你的任务如果无比简单，那没必要用复杂的 prompt；而如果你的任务是多步精确的推理，那么你的 prompt 复杂点反倒会让其执行地更加精确</p><h3 id=让-gemini-出手>让 Gemini 出手<a hidden class=anchor aria-hidden=true href=#让-gemini-出手>#</a></h3><p>有些时候可以让 Gemini 来修改你的 prompt，这里之所以是 Gemini，是因为其是所有 LLMs 最话痨的一个，会事无巨细地修改你的 prompt，让其更加精确具体，比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-md data-lang=md><span class=line><span class=cl>My objective is to xxx. Please re-frame the following prompt to make it easier for LLMs agents to follow.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>Your</span> <span class=na>Prompt</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>当然，别忘了对其返回的结果进行二次修改，多半情况下 Gemini 还会顺手把不需要改的地方也改了，也可以在一开始输入时限制它不要这么做。总之，检查还是必要的~</p><h2 id=使用场景>使用场景<a hidden class=anchor aria-hidden=true href=#使用场景>#</a></h2><h3 id=repo-qa>Repo QA<a hidden class=anchor aria-hidden=true href=#repo-qa>#</a></h3><p>这个其实是最靠谱的功能（写代码会出错，这个大概率不会），当上手一个新仓库时，或者阅读一段比较费解的代码，有时候可以让 CC 进行解释，以下列出几种提问方式：</p><ul><li>How is the logging module implemented?</li><li>Why does the line 139 in <code>xxx.py</code> call function <code>a()</code>?</li><li>What is the meaning of parameter <code>p</code> on line 139 of <code>xxx.py</code>?</li></ul><p>这个还可以反着用，当你在一个项目上加越来越多 feature，潜在的依赖关系就会越来越复杂，有时候你可能忙着实现一个 feature 而忘记一些依赖关系，也可以先让 CC 进行分析，此时就可以提前规避错误</p><h3 id=linter>Linter<a hidden class=anchor aria-hidden=true href=#linter>#</a></h3><p>这个是我经常使用的功能，写完代码后，可以让 CC 对代码进行检查，查看其是否符合 pythonic and neat 的要求，常见的修改需求如下：</p><ul><li>将某个大函数拆分为几个原子化的小函数</li><li>修改某个变量 / 函数的名字使其更加具体和精确</li><li>对复杂的模块及其参数添加注释</li><li>对函数的变量加上 type 标识</li></ul><h3 id=git-related>Git Related<a hidden class=anchor aria-hidden=true href=#git-related>#</a></h3><p>除了 Repo QA，CC 还可以 Git QA，比如你好奇某个模块的功能是在哪个 commit 实现的，或者是想要问责是哪个实现导致了目前的报错</p><p>同时还可以让 CC 帮助你完成 git 的提交，比如写 commit message 以及自动化 push</p><h2 id=tips>Tips<a hidden class=anchor aria-hidden=true href=#tips>#</a></h2><ul><li><code>/clear</code> 可以直接清除所有上下文</li><li><code>Shift+Tab</code> 可以灵活切换状态，比如「自动接受」</li><li>修改命令之后得重启 CC 才可以生效</li><li>可以向 CC 传数据，比如图片，或者是读取 URL 文件，本地文件可以通过路径来读，还可以使用管道命令，比如 <code>cat foo.txt | claude</code></li><li>多个 Claude 协同，这个适合一个 Claude 解决不了的时候，可以开两个终端，每个 CC 负责不同的功能，比如一个实现，一个检查</li><li>使用一些额外的工具，比如 MCP（Model Context Protocol），当然你也可以写一些「工具代码」供其调用</li><li>重要的提示词：比如 IMPORTANT，YOU MUST 来强调服从性；思考相关的：think, think hard, think harder（适合 Claude 模型）</li><li>有时候我们想一直「自动运行」，但它有时候会弹出一些「命令申请」，此时就可以在 <code>.claude/settings.local.json</code> 内加入一些命令的权限管理：<div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;env&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;BASH_DEFAULT_TIMEOUT_MS&#34;</span><span class=p>:</span> <span class=s2>&#34;3000000&#34;</span> <span class=c1>// bash command 超时时间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;permissions&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;allow&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Bash(*)&#34;</span><span class=p>,</span> <span class=c1>// 允许终端执行所有命令
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=s2>&#34;Bash(python:*)&#34;</span> <span class=c1>// 允许终端执行各种 Python 命令
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;deny&#34;</span><span class=p>:</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li></ul></div><div style="margin-top:2em;padding:1em;border:0 solid;border-radius:10px;background-color:var(--code-bg)"><h3>如果您想要引用，请考虑如下格式：</h3><div style=padding-top:.5em>台运鹏. (Jul. 12, 2025). 《Agentic Coding: 当编程被按下加速键》[Blog
post]. Retrieved from http://yunpengtai.top/posts/agentic-coding/</div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>@online{blog-36d4904aa975b135e0100899aff70f70,
</span></span><span class=line><span class=cl>        title={Agentic Coding: 当编程被按下加速键},
</span></span><span class=line><span class=cl>        author={Yunpeng Tai},
</span></span><span class=line><span class=cl>        year={2025},
</span></span><span class=line><span class=cl>        month={Jul},
</span></span><span class=line><span class=cl>        note={http://yunpengtai.top/posts/agentic-coding/},
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><div style=padding-bottom:.4em>自由转载-非商用-非衍生-保持署名（<a href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-SA 4.0）</a></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://yunpengtai.top/tags/agentic-coding/>agentic-coding</a></li><li><a href=http://yunpengtai.top/tags/prompt/>prompt</a></li><li><a href=http://yunpengtai.top/tags/claude-code/>claude-code</a></li></ul><nav class=paginav><a class=next href=http://yunpengtai.top/posts/muon/><span class=title>Next »</span><br><span>Muon: 控制谱范数下的最速下降</span></a></nav></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/artalk@2.8.6/dist/Artalk.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/@artalk/plugin-katex@0.2.4/dist/artalk-plugin-katex.min.js></script><div id=Comments></div><script>const savedTheme=localStorage.getItem("pref-theme");let darkMode="auto";savedTheme!==null&&(darkMode=savedTheme==="dark");const artalk=Artalk.init({el:"#Comments",pageKey:"",pageTitle:"Agentic Coding: 当编程被按下加速键",server:"https://comment.yunpengtai.top",site:"Tai's Blog",darkMode,versionCheck:!1});document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?artalk.setDarkMode(!1):artalk.setDarkMode(!0)})</script></article></main><footer class=footer><span>&copy; 2025 <a href=http://yunpengtai.top>Tai's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/sherlcok314159/MyPaperMod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("/js/pangu.min.js",function(){pangu.spacingPage()})</script><script>(function(){var e,t,n,s=document.getElementsByTagName("code");for(n=0;n<s.length;){if(t=s[n],t.parentNode.tagName!=="PRE"&&t.childElementCount===0&&(e=t.textContent,/^\$[^$]/.test(e)&&/[^$]\$$/.test(e)&&(e=e.replace(/^\$/,"\\(").replace(/\$$/,"\\)"),t.textContent=e),/^\\\((.|\s)+\\\)$/.test(e)||/^\\\[(.|\s)+\\\]$/.test(e)||/^\$(.|\s)+\$$/.test(e)||/^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(e))){t.outerHTML=t.innerHTML;continue}n++}})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>大模型的数学之路 | Tai's Blog</title><meta name=keywords content="LLM"><meta name=description content="问题 LLM 通过大量的语料来建模下一个 token 的概率，这种训练方式促成 LLM 成为一个「文科生」，那么我们不禁对以下几个问题好奇： LLM 目前在数学问题上取得的进展"><meta name=author content><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="eAKh7zszsOtNde1wyq_sUo95ZPH4zTTJhR-_ol4VWDs"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yunpengtai.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yunpengtai.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yunpengtai.top/favicon-32x32.png><link rel=apple-touch-icon href=https://yunpengtai.top/apple-touch-icon.png><link rel=mask-icon href=https://yunpengtai.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>MathJax={loader:{load:["[tex]/boldsymbol"]},tex:{tags:"all",inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,packages:{"[+]":["boldsymbol"]}}}</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml-full.js integrity="sha256-kbAFUDxdHwlYv01zraGjvjNZayxKtdoiJ38bDTFJtaQ=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y3CX2RWEDY"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y3CX2RWEDY",{anonymize_ip:!1})}</script><meta property="og:title" content="大模型的数学之路"><meta property="og:description" content="问题 LLM 通过大量的语料来建模下一个 token 的概率，这种训练方式促成 LLM 成为一个「文科生」，那么我们不禁对以下几个问题好奇： LLM 目前在数学问题上取得的进展"><meta property="og:type" content="article"><meta property="og:url" content="https://yunpengtai.top/posts/llm-math/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-25T13:16:00+08:00"><meta property="article:modified_time" content="2023-10-25T13:16:00+08:00"><meta property="og:site_name" content="Tai's Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yunpengtai.top/posts/"},{"@type":"ListItem","position":3,"name":"大模型的数学之路","item":"https://yunpengtai.top/posts/llm-math/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"大模型的数学之路","name":"大模型的数学之路","description":"问题 LLM 通过大量的语料来建模下一个 token 的概率，这种训练方式促成 LLM 成为一个「文科生」，那么我们不禁对以下几个问题好奇： LLM 目前在数学问题上取得的进展","keywords":["LLM"],"articleBody":" 问题 LLM 通过大量的语料来建模下一个 token 的概率，这种训练方式促成 LLM 成为一个「文科生」，那么我们不禁对以下几个问题好奇：\nLLM 目前在数学问题上取得的进展 有哪些技术路线在未来可能会更进一步提升 LLM 解决数学问题的能力？ 在以下部分不妨来讨论上面两个问题\n技术路线 那么在目前的模型中，分别有哪些方案呢？这里只会介绍各种路线关于数学的 key points，不会特别关注其他细节。另外 MathGPT 和 Abel 目前没有详细的 report，不会涉及\nInference Prompts LLM 直接输出答案经常会出错，第一条路线是通过 prompt 的不同方法来让模型不断「shift the distribution」，让模型不断调整输出分布，让结果更稳定和准确\nCoT 众所周知，CoT（Chain of Thought）是一种通过让模型一步步思考来提高模型推理能力的，下图右侧是 CoT\n下图横轴代表参数规模，当时通过 CoT 在 PaLM 上甚至超过了监督训练的 SOTA，CoT 这种方法就感觉像是「refine 模型输出的分布」，一步步思考也就意味着输出尽可能往正确的上面靠，相比之下，直接输出就像是「一锤定音」\nSelf-Verification 这篇工作就是进行反向验证，这篇工作看到还是比较开心的，刚好验证了自己之前的猜想\n举个例子来说，我们问模型一个问题，模型回答了两种答案：\n接下来我们将这个答案作为已知量，将题干中的变量当做未知，去反推，发现不一致，则说明答案有误\nFORBAR FORBAR 代指的是 Forward-Backward Reasoning，跟上面几乎一致，可以看个例子：\nForward 就是我们之前让模型直接算的，而 Backward 的意思就是我把题干中的一个变量给遮盖掉，变成 x，而我告诉你答案，我要反问你 x 是啥\n不同的是 Self-Verification 是用以验证，不能扩充成为 Examples，而 FORBAR 就可以作为 Examples\n效果是相当不错的：\nPoT Program of Thought 是不同于 CoT 的工作，出发点也很简单，比较复杂的数值推理任务，靠一步步推理，其实 LLM 还是会搞错\n那就有人想了，能不能不让 LLM 来计算，让 LLM 学会调用 Python 程序来搞呢？程序计算肯定比 LLM 自己来靠谱，这就是 PoT 干的事情：\n效果也是会比 CoT 好上一些，下图是 Few-Shot 的结果：\nMajority Voting 多数投票法（或称之为 self-consistency）是在 CoT 的基础上，对结果进行投票，在推理时，我们采样多个可能的解决方案，然后看最后那个预测结果出现最多，就选哪个\n结果也是比较显著的，比单独的 CoT 要好：\nWork Memory Galactica 提出了「工作记忆」的概念，先引入人类思考的习惯，当我让你求几个数字的平均值时，比如 43, 29, 51, 13，你会写一些过程在纸上，这种写出来的称之为 External Work Memory，即为外在工作记忆\n仔细看图中倒数两行的位置，有个 thinking，有些人算 136/4 是可以在脑中完成计算的，这种被称为 Internal Work Memory，而 Galatica 正是将两种记忆方式结合在一起解决问题。让我们看个 Work Memory 的例子：\n有人说，乍一看，这不就是 CoT 吗？一步步展开思考，没毛病吧，但你看 calculate 那里，这个过程是可以不需要 LLM 自己得出答案的，它可以只写个代码让计算机执行 Python 程序，而 LLM 做的是下达指令，读取输出即可\n具体而言，它跟 CoT 的区别或者说 CoT 的不足之处在于：\nCoT 相当于上面求平均值一直写在纸上的过程，但是有些 low-level 的思考人类是不需要写下来的，而 LLM 做不到这一点，这也是为什么 CoT 会产生看似正确但又模糊的答案，而 Work Memory 是将 internal 的思考交由更准确的工具去做，比如上述算力大小的例子，写程序，然后执行代码，最后 LLM 只需要读取就行了\n这个方法的难点在于数据集的准备，而 Galatica 是通过以下方法来创建：\n通过程序来控制一些变量，来生成例子（OneSmallStep） 从现成的数据集中拿（Workout, Khan Problems） 另一种就是直接用这种模版转换（GSM8k train） mCoT 即代表 Majority Voting + CoT 一起的，可以看到 mCoT 还是效果优于工作记忆的，不过工作记忆并没有经过很好的养成，数据集既不大也不多样，后面可以优化的空间肯定更多\n需要注意的是，不能单纯的拿和 mCoT 对比，因为上面 Galatica 的 prompt 数据集是预训练过的\nOPRO 这篇文章我也比较喜欢，目前 LLM 对于 prompt 不稳定，我猜测可能是不一致的原因：用人工优化的 prompt 来调整 LLM 内在输出分布，那很自然就有一个想法，能不能让 LLM 自己来优化使用的 prompt 呢？\n这就是 OPRO 做的事情，将 LLM 当做是优化器，不同于以往传统的优化任务，有各种公式做约束，OPRO 是用「自然语言描述」做约束，比如 Find the most effective prompt for this problem，具体框架如下：\n首先是用最开始 prompt，接着让负责优化 LLM 产生出多个 prompt，再根据目标用 负责打分 LLM 进行打分，将打分后的 prompt 和分数一起放进下一次优化中，最后输出分数最高的 prompt\n下图是 GMS8k 在优化 prompt 过程中的准确度，这里图可能有误解，其实没有 train，只是在优化过程中找到 prompt，然后在 eval set 进行评测准确率\nReward Models 第二条路线是改进 RLHF（Reinforcement Learning from Human Feedback）\nProcess Supervision We’ve trained a model to achieve a new state-of-the-art in mathematical problem solving by rewarding each correct step of reasoning (“process supervision”) instead of simply rewarding the correct final answer (“outcome supervision”).\n目前的奖励模型大多基于「结果监督」，追求让模型产出正确的结果，而这样的弊端在于两点：\n模型中间的思考过程是未知的，解释性和可靠性不高 无法真正实现 alignment with humans，只是去对齐结果 In addition to boosting performance relative to outcome supervision, process supervision also has an important alignment benefit: it directly trains the model to produce a chain-of-thought that is endorsed by humans.\n那么 OpenAI 的解决方案即引入「过程监督」，让模型每一步思考都和人类的进行对齐，这样就可以较好地解决以上的两个问题。作者还发现，尽管是过程监督，但只对比结果依然比结果监督要好\n同时 OpenAI 开源了过程监督的数据集 PRM800K，下图中 ORM 代表「Outcome Rewarded Model」，PRM 代表「Process Rewarded Model」\n当问题越复杂时，过程监督的优点就逐渐显露出来，结果好的同时更具解释性，可谓是一举两得\nReinforcement Learning from Evol-Instruct Feedback Reinforcement Learning from Evol-Instruct Feedback（RLEIF）是 WizardMath 提出的技术，设计比较巧妙，很 nice 的工作，一共分为三步：\n第一步：是先用指令微调获得模型 Wizard-E\n第二步：接着模仿 Evol-Instruct 利用 Wizard-E 和 ChatGPT 来扩充训练集，主要是分为两个方面，让问题变得更简单（Downward）和让问题更复杂（Upward），比如加更多限制，复杂化原来的问题。然后用 Wizard-E 进行排序，获得训练 Instruction Reward Model（IRM）的数据集\n再让 Wizard-E 模型来生成解决问题的步骤，用 ChatGPT 来评判每步的正确性，以此来生成训练 Process Supervision 的数据集\n第三步便是用 PPO 联合训练两个奖励模型，具体是将两个获得的奖励相乘，模型的效果也是比较惊艳的，不过在 MATH 数据集上还差点意思（可能是参数规模不够）\n数据入手 Galactica Galactica 用于预训练的数据量比同等大模型用的要小得多，整个数据集是经过清洗的「科学领域」数据集，包括论文，参考资料，蛋白质序列，化学公式等等，大小为仅有 106 billion tokens\n从上述表格可以看出，论文占了大头（83%），令人惊讶的是 CommonCrawl 仅仅占了 1%\n还将prompt数据集加入了预训练之中\n作者还提到 prompt prertraining 可以增强模型 general 的能力：\nMinerva 无独有偶，Minerva 同样收集了来自 arxiv 上的论文，有趣的是 General 的语料也是占比很少\n另外还收集了带有数学公式的网站：\n不一样的是利用方式，Minerva 采用的模型基座是 PaLM，然后在收集的数据上进行 Auto-regressive loss 微调\nRejection Sampling FineTuning 上面的 Galatica 和 Minvera 都是收集数据，是否可以让 LLM 生成数据呢？\nRFT（Rejection Sampling FineTuning）是阿里的工作，方法比较符合直觉，直接让微调后的模型来生成不同的例子用以扩充数据集，然后根据一些准则来筛选：\n答案不对的 计算结果和 Python 结果不一致的 可以看到效果比单纯的 SFT 要好上不少：\nAugGSM8K 还是那句话，我们可以用 LLM 来进行数据的扩充，问题是怎么扩充呢？这篇工作针对问题和回复分别进行了增强：\n关于问题，分别采用了五种增强策略（见下图左列），这些原则的设计还是比较符合直觉的\n对于回复，作者是采用不同的温度来生成多样化的推理路径，当然也会对于明显错误的进行过滤\n数据集概览如下：\n生成的数据集证明也是有效果的：\nMetaMath 这篇文章跟上面的 AugGSM8K 算是同期工作，也是利用 LLM 来对数据集进行增广，然后进行微调\n它主要是对问题进行增广，分为以下几种：\nRephrase Question Self-Verification FORBAR 效果的话基本和 AugGSM8K 也差不多，除了 70B 是 QLoRA，其他的参数是 LLaMA 的\nMAmmoTH 这篇工作是我数据分支线中很喜欢的一篇，其实 RFT 类通过 Bootstrap 来搞数据集的路子，会丧失「通用性」，在 GMS8K 上效果好，而在 MMLU-Math 上就有可能掉很多点；而 Galatica 和 Minvera 付出的代价要很多\n那么 MAmmoTH 就构建了一个数据集：MathInstruct：\n下图是其与其他数据集的对比：\n特点有三个：\n量大，一共有 200K 覆盖比较多的数学领域 Prompt 同时包括了 CoT 和 PoT 其实有些时候我觉得搞数据集是在水文章，但是有些时候是真的很有意义，比如 ImageNet，以及这一篇工作，方法再 fancy，数据缺少带来的问题是很难解决的\n效果也很顶，比 RFT 以及 Wizard 更具备通用性，是 Llama 就能有如此效果，相信换更大的模型肯定会有不错的提升\n架构 MathGLM 具备算数能力 这篇工作是相当有趣，它也解决了我的困惑，若 LLM 从一开始就学数值推理，能不能做好？同时，这篇工作给了一个全新的视角来做一个「专家模型」\n首先是其数据构造环节，很有启发性，无论是 CoT，还是工作区记忆，都强调需要把细节尽可能写下来，LLM 不能像人一样跳跃，这篇工作直接将推理的结果改成一步步得出\n接下来选用的主力 backbone 是 2B 的 Transformer-Decoder，你没有看错，这篇文章并没有使用 LLM Backbone，而是用 AutoRegressive loss 直接用上面数据集去训练\n下图的测试例子一共有 9592 条，直接碾压 GPT-4。当然，我认为这里的是裸模型，没加任何操作，如果用好的操作，GPT-4 应该可以做得更好。因为你拿一个垂域和一个通用模型比，至少也应该给 GPT-4 一些更好的 Prompt Method，或者一些上下文学习的例子\n不过这个实验结果证明了以下两点：\nDecoder-Only 架构的确可以学习到算数规则 参数的规模不需要那么大，2B 就能有很好的能力 通用一点的专家模型 为了让 MathGLM 可以解决文本描述的问题，MathGLM 还需要变得更通用，于是把目光放到了带有描述的数据集，同样的，将原来的解题步骤进行了细化，这样的好处是，既可以学习到数学知识，又可以建模文本，相当于比之前的专家模型更具通用性\n路在何方 那么理想化 LLM 能解决数学问题的标准是什么呢？\n题目的解答得正确 解题过程正确可解释 这两点是有可能做到的。综合以上的论文，我大胆预测一下未来的 Math LLM 可能的发展趋势，思路肯定是做一个较为通用的「专家模型」，具体怎么做呢？\n数据的收集和处理 数据的收集前面的工作可谓是百花齐放，核心思路就三个：\n尽可能人工去搞高质量的数学推理数据集，你像 LLM 在文本领域能成功，肯定离不开大量的高质量数据集 如果特别强领域特性的没有，就找更接近的，比如论文这种科学领域的语料 实在不行，就想办法让 LLM 来自我产生数据集（Bootstrap），但这种很依赖于模型，且会引入模型的内在 Bias，但不失为提升模型的手段 数据的处理这块看着比较简单，其实不然\n举个例子，MetaMath 就将答案改写成一步步过程，引入第一个数据原则：detailed，把 LLM 当成弱智，越详细越好\n第二个是 Minerva 的处理，它将公式单独处理成 LaTeX 中见到的样子，就相当于你用特殊的 token 来包裹公式，用某种方式来提示 LLM，第二个原则：保留不同于文本的模态特征\n专家模型的路线 这一点其实 MathGLM 和 Galatica 给了我不少启发，但目前有一个问题尚未解决：\n如果先预训练 Math LLM，后期去建模文本，究竟能保留多少通用性，或者反过来，如何保留数学的能力，说到底就是 how to be general and specific，如何衡量「通用性」和「专用型」，是值得考量的\n决定之后，其实就可以借鉴这两个模型的路子，比如将 Prompt 数据集直接放入预训练中，以及用 AutoRegressive loss 去建模数值推理的例子等\n预训练完毕，再利用 SFT 或是 RLHF 类方法去进一步微调\n参数的规模我觉得应该不会需要很大，相反，对于数据如何利用是值得考量的，正如在 Galatica 中提到的：作者们发现当重复训练时，性能也会稳步上升，作者将此归因于高质量的数据\n更强的推理方法 从简单的 Zero-Shot 再到 CoT，到 OPRO，经历了太多 Prompt 方法的变迁，我想未来应该很会有，但趋势应该是如何将 LLM 本身的知识引入其中来选择或构造 Prompt，这种一致性带来的提升会更稳定和持久\n最后一个问题 How to leverage LLM’s intrinsic ability to do reasoning?\n这也是我最近一直在想的问题，你看在数据那块，你会发现让模型生成一些例子再放进去推理会比直接推理要好一些，这都是模型自己的能力，有没有什么更优雅的方法可以将这种能力抽离出来\n换句话说，我们对 LLM 本身能力的压榨是不是还有上升的空间？\nReferences https://openai.com/research/improving-mathematical-reasoning-with-process-supervision https://galactica.org/static/paper.pdf https://arxiv.org/abs/2203.11171 https://arxiv.org/abs/2201.11903 https://arxiv.org/abs/2206.14858 http://arxiv.org/abs/2309.03409 https://arxiv.org/pdf/2308.09583.pdf https://arxiv.org/abs/2304.12244 http://arxiv.org/abs/2308.01825 https://arxiv.org/abs/2309.05653 https://arxiv.org/abs/2211.12588 http://arxiv.org/abs/2310.05506 http://arxiv.org/abs/2309.03241 https://arxiv.org/abs/2309.12284 https://arxiv.org/abs/2308.07758 https://arxiv.org/abs/2212.09561 ","wordCount":"4932","inLanguage":"en","datePublished":"2023-10-25T13:16:00+08:00","dateModified":"2023-10-25T13:16:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://yunpengtai.top/posts/llm-math/"},"publisher":{"@type":"Organization","name":"Tai's Blog","logo":{"@type":"ImageObject","url":"https://yunpengtai.top/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://yunpengtai.top accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://yunpengtai.top/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://yunpengtai.top/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yunpengtai.top/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yunpengtai.top/friends/ title=Friends><span>Friends</span></a></li><li><a href=https://yunpengtai.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yunpengtai.top>Home</a>&nbsp;»&nbsp;<a href=https://yunpengtai.top/posts/>Posts</a></div><h1 class=post-title>大模型的数学之路</h1><div class=post-meta><span title='2023-10-25 13:16:00 +0800 CST'>October 25, 2023</span>&nbsp;·&nbsp;4932 words</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e9%97%ae%e9%a2%98 aria-label=问题>问题</a></li><li><a href=#%e6%8a%80%e6%9c%af%e8%b7%af%e7%ba%bf aria-label=技术路线>技术路线</a><ul><li><a href=#inference-prompts aria-label="Inference Prompts">Inference Prompts</a><ul><li><a href=#cot aria-label=CoT>CoT</a></li><li><a href=#self-verification aria-label=Self-Verification>Self-Verification</a></li><li><a href=#forbar aria-label=FORBAR>FORBAR</a></li><li><a href=#pot aria-label=PoT>PoT</a></li><li><a href=#majority-voting aria-label="Majority Voting">Majority Voting</a></li><li><a href=#work-memory aria-label="Work Memory">Work Memory</a></li><li><a href=#opro aria-label=OPRO>OPRO</a></li></ul></li><li><a href=#reward-models aria-label="Reward Models">Reward Models</a><ul><li><a href=#process-supervision aria-label="Process Supervision">Process Supervision</a></li><li><a href=#reinforcement-learning-from-evol-instruct-feedback aria-label="Reinforcement Learning from Evol-Instruct Feedback">Reinforcement Learning from Evol-Instruct Feedback</a></li></ul></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%85%a5%e6%89%8b aria-label=数据入手>数据入手</a><ul><li><a href=#galactica aria-label=Galactica>Galactica</a></li><li><a href=#minerva aria-label=Minerva>Minerva</a></li><li><a href=#rejection-sampling-finetuning aria-label="Rejection Sampling FineTuning">Rejection Sampling FineTuning</a></li><li><a href=#auggsm8k aria-label=AugGSM8K>AugGSM8K</a></li><li><a href=#metamath aria-label=MetaMath>MetaMath</a></li><li><a href=#mammoth aria-label=MAmmoTH>MAmmoTH</a></li></ul></li><li><a href=#%e6%9e%b6%e6%9e%84 aria-label=架构>架构</a><ul><li><a href=#mathglm aria-label=MathGLM>MathGLM</a><ul><li><a href=#%e5%85%b7%e5%a4%87%e7%ae%97%e6%95%b0%e8%83%bd%e5%8a%9b aria-label=具备算数能力>具备算数能力</a></li><li><a href=#%e9%80%9a%e7%94%a8%e4%b8%80%e7%82%b9%e7%9a%84%e4%b8%93%e5%ae%b6%e6%a8%a1%e5%9e%8b aria-label=通用一点的专家模型>通用一点的专家模型</a></li></ul></li></ul></li></ul></li><li><a href=#%e8%b7%af%e5%9c%a8%e4%bd%95%e6%96%b9 aria-label=路在何方>路在何方</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%9a%84%e6%94%b6%e9%9b%86%e5%92%8c%e5%a4%84%e7%90%86 aria-label=数据的收集和处理>数据的收集和处理</a></li><li><a href=#%e4%b8%93%e5%ae%b6%e6%a8%a1%e5%9e%8b%e7%9a%84%e8%b7%af%e7%ba%bf aria-label=专家模型的路线>专家模型的路线</a></li><li><a href=#%e6%9b%b4%e5%bc%ba%e7%9a%84%e6%8e%a8%e7%90%86%e6%96%b9%e6%b3%95 aria-label=更强的推理方法>更强的推理方法</a></li><li><a href=#%e6%9c%80%e5%90%8e%e4%b8%80%e4%b8%aa%e9%97%ae%e9%a2%98 aria-label=最后一个问题>最后一个问题</a></li></ul></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698493462.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698493462.png#center width=600 height=800></figure></a><h2 id=问题>问题<a hidden class=anchor aria-hidden=true href=#问题>#</a></h2><p>LLM 通过大量的语料来建模下一个 token 的概率，这种训练方式促成 LLM 成为一个「文科生」，那么我们不禁对以下几个问题好奇：</p><ol><li>LLM 目前在数学问题上取得的进展</li><li>有哪些技术路线在未来可能会更进一步提升 LLM 解决数学问题的能力？</li></ol><p>在以下部分不妨来讨论上面两个问题</p><h2 id=技术路线>技术路线<a hidden class=anchor aria-hidden=true href=#技术路线>#</a></h2><p>那么在目前的模型中，分别有哪些方案呢？这里只会介绍各种路线关于数学的 key points，不会特别关注其他细节。另外 <a href=https://www.mathgpt.com/>MathGPT</a> 和 <a href=https://github.com/GAIR-NLP/abel>Abel</a> 目前没有详细的 report，不会涉及</p><h3 id=inference-prompts>Inference Prompts<a hidden class=anchor aria-hidden=true href=#inference-prompts>#</a></h3><p>LLM 直接输出答案经常会出错，第一条路线是通过 prompt 的不同方法来让模型不断「shift the distribution」，让模型不断调整输出分布，让结果更稳定和准确</p><h4 id=cot>CoT<a hidden class=anchor aria-hidden=true href=#cot>#</a></h4><p>众所周知，CoT（Chain of Thought）是一种通过让模型一步步思考来提高模型推理能力的，下图右侧是 CoT</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498590.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498590.png#center width=600 height=300></figure></a><p>下图横轴代表参数规模，当时通过 CoT 在 PaLM 上甚至超过了监督训练的 SOTA，CoT 这种方法就感觉像是「refine 模型输出的分布」，一步步思考也就意味着输出尽可能往正确的上面靠，相比之下，直接输出就像是「一锤定音」</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498592.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498592.png#center width=600 height=400></figure></a><h4 id=self-verification>Self-Verification<a hidden class=anchor aria-hidden=true href=#self-verification>#</a></h4><p>这篇工作就是进行反向验证，这篇工作看到还是比较开心的，刚好验证了自己之前的猜想</p><p>举个例子来说，我们问模型一个问题，模型回答了两种答案：</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498595.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498595.png#center width=600 height=450></figure></a><p>接下来我们将这个答案作为已知量，将题干中的变量当做未知，去反推，发现不一致，则说明答案有误</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498597.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498597.png#center width=700 height=300></figure></a><h4 id=forbar>FORBAR<a hidden class=anchor aria-hidden=true href=#forbar>#</a></h4><p>FORBAR 代指的是 Forward-Backward Reasoning，跟上面几乎一致，可以看个例子：</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498599.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498599.png#center width=600 height=300></figure></a><p>Forward 就是我们之前让模型直接算的，而 Backward 的意思就是我把题干中的一个变量给遮盖掉，变成 x，而我告诉你答案，我要反问你 x 是啥</p><p>不同的是 Self-Verification 是用以验证，不能扩充成为 Examples，而 FORBAR 就可以作为 Examples</p><p>效果是相当不错的：</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498601.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498601.png#center width=650 height=300></figure></a><h4 id=pot>PoT<a hidden class=anchor aria-hidden=true href=#pot>#</a></h4><p>Program of Thought 是不同于 CoT 的工作，出发点也很简单，比较复杂的数值推理任务，靠一步步推理，其实 LLM 还是会搞错</p><p>那就有人想了，能不能不让 LLM 来计算，让 LLM 学会调用 Python 程序来搞呢？程序计算肯定比 LLM 自己来靠谱，这就是 PoT 干的事情：</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498603.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498603.png#center width=700 height=300></figure></a><p>效果也是会比 CoT 好上一些，下图是 Few-Shot 的结果：</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498605.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498605.png#center width=600 height=300></figure></a><h4 id=majority-voting>Majority Voting<a hidden class=anchor aria-hidden=true href=#majority-voting>#</a></h4><p>多数投票法（或称之为 self-consistency）是在 CoT 的基础上，对结果进行投票，在推理时，我们采样多个可能的解决方案，然后看最后那个预测结果出现最多，就选哪个</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498607.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498607.png#center width=700 height=300></figure></a><p>结果也是比较显著的，比单独的 CoT 要好：</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498609.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498609.png#center width=700 height=300></figure></a><h4 id=work-memory>Work Memory<a hidden class=anchor aria-hidden=true href=#work-memory>#</a></h4><p>Galactica 提出了「工作记忆」的概念，先引入人类思考的习惯，当我让你求几个数字的平均值时，比如 43, 29, 51, 13，你会写一些过程在纸上，这种写出来的称之为 External Work Memory，即为外在工作记忆</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698500113.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698500113.png#center width=500 height=800></figure></a><p>仔细看图中倒数两行的位置，有个 thinking，有些人算 136/4 是可以在脑中完成计算的，这种被称为 Internal Work Memory，而 Galatica 正是将两种记忆方式结合在一起解决问题。让我们看个 Work Memory 的例子：</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498613.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498613.png#center width=600 height=400></figure></a><p>有人说，乍一看，这不就是 CoT 吗？一步步展开思考，没毛病吧，但你看 calculate 那里，这个过程是可以不需要 LLM 自己得出答案的，它可以只写个代码让计算机执行 Python 程序，而 LLM 做的是下达指令，读取输出即可</p><p>具体而言，它跟 CoT 的区别或者说 CoT 的不足之处在于：</p><p>CoT 相当于上面求平均值一直写在纸上的过程，但是有些 low-level 的思考人类是不需要写下来的，而 LLM 做不到这一点，这也是为什么 CoT 会产生看似正确但又模糊的答案，而 Work Memory 是将 internal 的思考交由更准确的工具去做，比如上述算力大小的例子，写程序，然后执行代码，最后 LLM 只需要读取就行了</p><p>这个方法的难点在于数据集的准备，而 Galatica 是通过以下方法来创建：</p><ul><li>通过程序来控制一些变量，来生成例子（OneSmallStep）</li><li>从现成的数据集中拿（Workout, Khan Problems）</li><li>另一种就是直接用&lt;work>这种模版转换（GSM8k train）</li></ul><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498615.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498615.png#center width=750 height=300></figure></a><p>mCoT 即代表 Majority Voting + CoT 一起的，可以看到 mCoT 还是效果优于工作记忆的，不过工作记忆并没有经过很好的养成，数据集既不大也不多样，后面可以优化的空间肯定更多</p><div class="notice notice-warning"><div class=notice-title><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 576 512" fill="hsl(0, 65%, 65%)"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zM124 296c-6.6.0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6.0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H124z"/></svg></div><p>需要注意的是，不能单纯的拿&lt;work>和 mCoT 对比，因为上面 Galatica 的 prompt 数据集是预训练过的</p></div><h4 id=opro>OPRO<a hidden class=anchor aria-hidden=true href=#opro>#</a></h4><p>这篇文章我也比较喜欢，目前 LLM 对于 prompt 不稳定，我猜测可能是不一致的原因：用人工优化的 prompt 来调整 LLM 内在输出分布，那很自然就有一个想法，能不能让 LLM 自己来优化使用的 prompt 呢？</p><p>这就是 OPRO 做的事情，将 LLM 当做是优化器，不同于以往传统的优化任务，有各种公式做约束，OPRO 是用「自然语言描述」做约束，比如 Find the most effective prompt for this problem，具体框架如下：</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498617.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498617.png#center width=650 height=400></figure></a><p>首先是用最开始 prompt，接着让负责优化 LLM 产生出多个 prompt，再根据目标用 负责打分 LLM 进行打分，将打分后的 prompt 和分数一起放进下一次优化中，最后输出分数最高的 prompt</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498619.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498619.png#center width=700 height=180></figure></a><p>下图是 GMS8k 在优化 prompt 过程中的准确度，这里图可能有误解，其实没有 train，只是在优化过程中找到 prompt，然后在 eval set 进行评测准确率</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498621.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498621.png#center width=700 height=250></figure></a><h3 id=reward-models>Reward Models<a hidden class=anchor aria-hidden=true href=#reward-models>#</a></h3><p>第二条路线是改进 RLHF（Reinforcement Learning from Human Feedback）</p><h4 id=process-supervision>Process Supervision<a hidden class=anchor aria-hidden=true href=#process-supervision>#</a></h4><blockquote><p>We&rsquo;ve trained a model to achieve a new state-of-the-art in mathematical problem solving by rewarding each correct step of reasoning (“process supervision”) instead of simply rewarding the correct final answer (“outcome supervision”).</p></blockquote><p>目前的奖励模型大多基于「结果监督」，追求让模型产出正确的结果，而这样的弊端在于两点：</p><ul><li>模型中间的思考过程是未知的，解释性和可靠性不高</li><li>无法真正实现 alignment with humans，只是去对齐结果</li></ul><blockquote><p>In addition to boosting performance relative to outcome supervision, process supervision also has an important alignment benefit: it directly trains the model to produce a chain-of-thought that is endorsed by humans.</p></blockquote><p>那么 OpenAI 的解决方案即引入「过程监督」，让模型每一步思考都和人类的进行对齐，这样就可以较好地解决以上的两个问题。作者还发现，尽管是过程监督，但只对比结果依然比结果监督要好</p><p>同时 OpenAI 开源了过程监督的数据集 PRM800K，下图中 ORM 代表「Outcome Rewarded Model」，PRM 代表「Process Rewarded Model」</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498624.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498624.png#center width=600 height=500></figure></a><p>当问题越复杂时，过程监督的优点就逐渐显露出来，结果好的同时更具解释性，可谓是一举两得</p><h4 id=reinforcement-learning-from-evol-instruct-feedback>Reinforcement Learning from Evol-Instruct Feedback<a hidden class=anchor aria-hidden=true href=#reinforcement-learning-from-evol-instruct-feedback>#</a></h4><p>Reinforcement Learning from Evol-Instruct Feedback（RLEIF）是 WizardMath 提出的技术，设计比较巧妙，很 nice 的工作，一共分为三步：</p><p>第一步：是先用指令微调获得模型 Wizard-E</p><p>第二步：接着模仿 Evol-Instruct 利用 Wizard-E 和 ChatGPT 来扩充训练集，主要是分为两个方面，让问题变得更简单（Downward）和让问题更复杂（Upward），比如加更多限制，复杂化原来的问题。然后用 Wizard-E 进行排序，获得训练 Instruction Reward Model（IRM）的数据集</p><p>再让 Wizard-E 模型来生成解决问题的步骤，用 ChatGPT 来评判每步的正确性，以此来生成训练 Process Supervision 的数据集</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498627.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498627.png#center width=600 height=500></figure></a><p>第三步便是用 PPO 联合训练两个奖励模型，具体是将两个获得的奖励相乘，模型的效果也是比较惊艳的，不过在 MATH 数据集上还差点意思（可能是参数规模不够）</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498629.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498629.png#center width=600 height=250></figure></a><h3 id=数据入手>数据入手<a hidden class=anchor aria-hidden=true href=#数据入手>#</a></h3><h4 id=galactica>Galactica<a hidden class=anchor aria-hidden=true href=#galactica>#</a></h4><p>Galactica 用于预训练的数据量比同等大模型用的要小得多，整个数据集是经过清洗的「科学领域」数据集，包括论文，参考资料，蛋白质序列，化学公式等等，大小为仅有 106 billion tokens</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498631.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498631.png#center width=600 height=300></figure></a><p>从上述表格可以看出，论文占了大头（83%），令人惊讶的是 CommonCrawl 仅仅占了 1%</p><div class="notice notice-tip"><div class=notice-title><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512" fill="hsl(140, 65%, 65%)"><path d="M504 256A248 248 0 118 256a248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z"/></svg></div><p>还将prompt数据集加入了预训练之中</p></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498633.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498633.png#center width=600 height=180></figure></a><p>作者还提到 prompt prertraining 可以增强模型 general 的能力：</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498636.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498636.png#center width=600 height=300></figure></a><h4 id=minerva>Minerva<a hidden class=anchor aria-hidden=true href=#minerva>#</a></h4><p>无独有偶，Minerva 同样收集了来自 arxiv 上的论文，有趣的是 General 的语料也是占比很少</p><p>另外还收集了带有数学公式的网站：</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498638.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498638.png#center width=650 height=150></figure></a><p>不一样的是利用方式，Minerva 采用的模型基座是 PaLM，然后在收集的数据上进行 Auto-regressive loss 微调</p><h4 id=rejection-sampling-finetuning>Rejection Sampling FineTuning<a hidden class=anchor aria-hidden=true href=#rejection-sampling-finetuning>#</a></h4><p>上面的 Galatica 和 Minvera 都是收集数据，是否可以让 LLM 生成数据呢？</p><p>RFT（Rejection Sampling FineTuning）是阿里的工作，方法比较符合直觉，直接让微调后的模型来生成不同的例子用以扩充数据集，然后根据一些准则来筛选：</p><ol><li>答案不对的</li><li>计算结果和 Python 结果不一致的</li></ol><p>可以看到效果比单纯的 SFT 要好上不少：</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498640.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498640.png#center width=700 height=150></figure></a><h4 id=auggsm8k>AugGSM8K<a hidden class=anchor aria-hidden=true href=#auggsm8k>#</a></h4><p>还是那句话，我们可以用 LLM 来进行数据的扩充，问题是怎么扩充呢？这篇工作针对问题和回复分别进行了增强：</p><p>关于问题，分别采用了五种增强策略（见下图左列），这些原则的设计还是比较符合直觉的</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498642.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498642.png#center width=600 height=400></figure></a><p>对于回复，作者是采用不同的温度来生成多样化的推理路径，当然也会对于明显错误的进行过滤</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498645.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498645.png#center width=600 height=400></figure></a><p>数据集概览如下：</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498647.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498647.png#center width=600 height=300></figure></a><p>生成的数据集证明也是有效果的：</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498649.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498649.png#center width=700 height=300></figure></a><h4 id=metamath>MetaMath<a hidden class=anchor aria-hidden=true href=#metamath>#</a></h4><p>这篇文章跟上面的 AugGSM8K 算是同期工作，也是利用 LLM 来对数据集进行增广，然后进行微调</p><p>它主要是对问题进行增广，分为以下几种：</p><ul><li>Rephrase Question</li><li>Self-Verification</li><li>FORBAR</li></ul><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498651.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498651.png#center width=700 height=300></figure></a><p>效果的话基本和 AugGSM8K 也差不多，除了 70B 是 QLoRA，其他的参数是 LLaMA 的</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498653.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498653.png#center width=700 height=300></figure></a><h4 id=mammoth>MAmmoTH<a hidden class=anchor aria-hidden=true href=#mammoth>#</a></h4><p>这篇工作是我数据分支线中很喜欢的一篇，其实 RFT 类通过 Bootstrap 来搞数据集的路子，会丧失「通用性」，在 GMS8K 上效果好，而在 MMLU-Math 上就有可能掉很多点；而 Galatica 和 Minvera 付出的代价要很多</p><p>那么 MAmmoTH 就构建了一个数据集：MathInstruct：</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498655.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498655.png#center width=700 height=250></figure></a><p>下图是其与其他数据集的对比：</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498657.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498657.png#center width=700 height=400></figure></a><p>特点有三个：</p><ul><li>量大，一共有 200K</li><li>覆盖比较多的数学领域</li><li>Prompt 同时包括了 CoT 和 PoT</li></ul><p>其实有些时候我觉得搞数据集是在水文章，但是有些时候是真的很有意义，比如 ImageNet，以及这一篇工作，方法再 fancy，数据缺少带来的问题是很难解决的</p><p>效果也很顶，比 RFT 以及 Wizard 更具备通用性，是 Llama 就能有如此效果，相信换更大的模型肯定会有不错的提升</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498660.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498660.png#center width=700 height=350></figure></a><h3 id=架构>架构<a hidden class=anchor aria-hidden=true href=#架构>#</a></h3><h4 id=mathglm>MathGLM<a hidden class=anchor aria-hidden=true href=#mathglm>#</a></h4><h5 id=具备算数能力>具备算数能力<a hidden class=anchor aria-hidden=true href=#具备算数能力>#</a></h5><p>这篇工作是相当有趣，它也解决了我的困惑，若 LLM 从一开始就学数值推理，能不能做好？同时，这篇工作给了一个全新的视角来做一个「专家模型」</p><p>首先是其数据构造环节，很有启发性，无论是 CoT，还是工作区记忆，都强调需要把细节尽可能写下来，LLM 不能像人一样跳跃，这篇工作直接将推理的结果改成一步步得出</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498662.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498662.png#center width=700 height=250></figure></a><p>接下来选用的主力 backbone 是 2B 的 Transformer-Decoder，你没有看错，这篇文章并没有使用 LLM Backbone，而是用 AutoRegressive loss 直接用上面数据集去训练</p><p>下图的测试例子一共有 9592 条，直接碾压 GPT-4。当然，我认为这里的是裸模型，没加任何操作，如果用好的操作，GPT-4 应该可以做得更好。因为你拿一个垂域和一个通用模型比，至少也应该给 GPT-4 一些更好的 Prompt Method，或者一些上下文学习的例子</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498664.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498664.png#center width=600 height=300></figure></a><p>不过这个实验结果证明了以下两点：</p><ol><li>Decoder-Only 架构的确可以学习到算数规则</li><li>参数的规模不需要那么大，2B 就能有很好的能力</li></ol><h5 id=通用一点的专家模型>通用一点的专家模型<a hidden class=anchor aria-hidden=true href=#通用一点的专家模型>#</a></h5><p>为了让 MathGLM 可以解决文本描述的问题，MathGLM 还需要变得更通用，于是把目光放到了带有描述的数据集，同样的，将原来的解题步骤进行了细化，这样的好处是，既可以学习到数学知识，又可以建模文本，相当于比之前的专家模型更具通用性</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498666.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498666.png#center width=700 height=300></figure></a><h2 id=路在何方>路在何方<a hidden class=anchor aria-hidden=true href=#路在何方>#</a></h2><p>那么理想化 LLM 能解决数学问题的标准是什么呢？</p><ol><li>题目的解答得正确</li><li>解题过程正确可解释</li></ol><p>这两点是有可能做到的。综合以上的论文，我大胆预测一下未来的 Math LLM 可能的发展趋势，思路肯定是做一个较为通用的「专家模型」，具体怎么做呢？</p><h3 id=数据的收集和处理>数据的收集和处理<a hidden class=anchor aria-hidden=true href=#数据的收集和处理>#</a></h3><p>数据的收集前面的工作可谓是百花齐放，核心思路就三个：</p><ul><li>尽可能人工去搞高质量的数学推理数据集，你像 LLM 在文本领域能成功，肯定离不开大量的高质量数据集</li><li>如果特别强领域特性的没有，就找更接近的，比如论文这种科学领域的语料</li><li>实在不行，就想办法让 LLM 来自我产生数据集（Bootstrap），但这种很依赖于模型，且会引入模型的内在 Bias，但不失为提升模型的手段</li></ul><p>数据的处理这块看着比较简单，其实不然</p><p>举个例子，MetaMath 就将答案改写成一步步过程，引入第一个数据原则：detailed，把 LLM 当成弱智，越详细越好</p><p>第二个是 Minerva 的处理，它将公式单独处理成 LaTeX 中见到的样子，就相当于你用特殊的 token 来包裹公式，用某种方式来提示 LLM，第二个原则：保留不同于文本的模态特征</p><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<a data-fancybox=gallery href=https://png.yunpengtai.top/2023/10/1698498669.png><figure class=align-center><img loading=lazy src=https://png.yunpengtai.top/2023/10/1698498669.png#center width=700 height=300></figure></a><h3 id=专家模型的路线>专家模型的路线<a hidden class=anchor aria-hidden=true href=#专家模型的路线>#</a></h3><p>这一点其实 MathGLM 和 Galatica 给了我不少启发，但目前有一个问题尚未解决：</p><p>如果先预训练 Math LLM，后期去建模文本，究竟能保留多少通用性，或者反过来，如何保留数学的能力，说到底就是 how to be general and specific，如何衡量「通用性」和「专用型」，是值得考量的</p><p>决定之后，其实就可以借鉴这两个模型的路子，比如将 Prompt 数据集直接放入预训练中，以及用 AutoRegressive loss 去建模数值推理的例子等</p><p>预训练完毕，再利用 SFT 或是 RLHF 类方法去进一步微调</p><p>参数的规模我觉得应该不会需要很大，相反，对于数据如何利用是值得考量的，正如在 Galatica 中提到的：作者们发现当重复训练时，性能也会稳步上升，作者将此归因于高质量的数据</p><h3 id=更强的推理方法>更强的推理方法<a hidden class=anchor aria-hidden=true href=#更强的推理方法>#</a></h3><p>从简单的 Zero-Shot 再到 CoT，到 OPRO，经历了太多 Prompt 方法的变迁，我想未来应该很会有，但趋势应该是如何将 LLM 本身的知识引入其中来选择或构造 Prompt，这种一致性带来的提升会更稳定和持久</p><h3 id=最后一个问题>最后一个问题<a hidden class=anchor aria-hidden=true href=#最后一个问题>#</a></h3><blockquote><p>How to leverage LLM&rsquo;s intrinsic ability to do reasoning?</p></blockquote><p>这也是我最近一直在想的问题，你看在数据那块，你会发现让模型生成一些例子再放进去推理会比直接推理要好一些，这都是模型自己的能力，有没有什么更优雅的方法可以将这种能力抽离出来</p><p>换句话说，我们对 LLM 本身能力的压榨是不是还有上升的空间？</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ol><li><a href=https://openai.com/research/improving-mathematical-reasoning-with-process-supervision>https://openai.com/research/improving-mathematical-reasoning-with-process-supervision</a></li><li><a href=https://galactica.org/static/paper.pdf>https://galactica.org/static/paper.pdf</a></li><li><a href=https://arxiv.org/abs/2203.11171>https://arxiv.org/abs/2203.11171</a></li><li><a href=https://arxiv.org/abs/2201.11903>https://arxiv.org/abs/2201.11903</a></li><li><a href=https://arxiv.org/abs/2206.14858>https://arxiv.org/abs/2206.14858</a></li><li><a href=http://arxiv.org/abs/2309.03409>http://arxiv.org/abs/2309.03409</a></li><li><a href=https://arxiv.org/pdf/2308.09583.pdf>https://arxiv.org/pdf/2308.09583.pdf</a></li><li><a href=https://arxiv.org/abs/2304.12244>https://arxiv.org/abs/2304.12244</a></li><li><a href=http://arxiv.org/abs/2308.01825>http://arxiv.org/abs/2308.01825</a></li><li><a href=https://arxiv.org/abs/2309.05653>https://arxiv.org/abs/2309.05653</a></li><li><a href=https://arxiv.org/abs/2211.12588>https://arxiv.org/abs/2211.12588</a></li><li><a href=http://arxiv.org/abs/2310.05506>http://arxiv.org/abs/2310.05506</a></li><li><a href=http://arxiv.org/abs/2309.03241>http://arxiv.org/abs/2309.03241</a></li><li><a href=https://arxiv.org/abs/2309.12284>https://arxiv.org/abs/2309.12284</a></li><li><a href=https://arxiv.org/abs/2308.07758>https://arxiv.org/abs/2308.07758</a></li><li><a href=https://arxiv.org/abs/2212.09561>https://arxiv.org/abs/2212.09561</a></li></ol></div><blockquote class=quote-copyright>Author: Yunpengtai<p>Link: https://yunpengtai.top/posts/llm-math/<p>License: CC BY-NC-SA 4.0. You must provide a link to the source.</blockquote><footer class=post-footer><ul class=post-tags><li><a href=https://yunpengtai.top/tags/llm/>LLM</a></li></ul><nav class=paginav><a class=prev href=https://yunpengtai.top/posts/better-prompt/><span class=title>« Prev</span><br><span>How to prompt LLM better?</span></a>
<a class=next href=https://yunpengtai.top/posts/efficient-tricks-for-llm/><span class=title>Next »</span><br><span>Efficient Tricks for LLMs</span></a></nav></footer><!doctype html><head><link rel=stylesheet href=https://unpkg.com/@waline/client@v2/dist/waline.css></head><body><div id=waline></div><script type=module>
    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';

    init({
      el: '#waline',
      lang: 'en',
      reaction: true,
      theme: 'dark',
      avatar: "mp",
      serverURL: 'https:\/\/example.yunpengtai.top\/',
      emoji: [
        'https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs',
        'https://unpkg.com/@waline/emojis@1.1.0/tw-emoji',
        'https://unpkg.com/@waline/emojis@1.1.0/bmoji'
    ],
      reaction:[
        'https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatheart.png',
        'https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatrainbow.png',
        'https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatattentionreverse.png',
        'https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/ablobcatheartbroken.png',
        'https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/blobcatopenmouth.png',
        'https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/blobcatcoffee.png'
      ],
      locale: {
        placeholder: '可以匿名评论哦~ QQ邮箱可自动获取头像 Anything to say? It can be anonymous.',
        level0: '潜水',
        level1: '冒泡',
        level2: '摸鱼',
        level3: '话痨',
        level4: '话满天',
        level5: '龙王',
      }
  });
  </script></body></html></article></main><footer class=footer><span>&copy; 2024 <a href=https://yunpengtai.top>Tai's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/sherlcok314159/MyPaperMod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>(function(){var e,t,n,s=document.getElementsByTagName("code");for(n=0;n<s.length;){if(t=s[n],t.parentNode.tagName!=="PRE"&&t.childElementCount===0&&(e=t.textContent,/^\$[^$]/.test(e)&&/[^$]\$$/.test(e)&&(e=e.replace(/^\$/,"\\(").replace(/\$$/,"\\)"),t.textContent=e),/^\\\((.|\s)+\\\)$/.test(e)||/^\\\[(.|\s)+\\\]$/.test(e)||/^\$(.|\s)+\$$/.test(e)||/^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(e))){t.outerHTML=t.innerHTML;continue}n++}})()</script><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("//cdn.bootcss.com/pangu/4.0.7/pangu.min.js",function(){pangu.spacingPage()})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>